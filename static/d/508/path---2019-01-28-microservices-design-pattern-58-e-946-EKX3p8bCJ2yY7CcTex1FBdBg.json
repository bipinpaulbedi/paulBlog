{"data":{"site":{"siteMetadata":{"title":"paul blog","description":"thoughts, stories & ideas.","author":"Bipin Paul Bedi","siteUrl":"https://www.bipinpaulbedi.com"}},"markdownRemark":{"id":"ed3d1d43-7c2b-57f8-b309-3f5b110c3ecb","excerpt":"Microservice has been a game changer in software development in the last few years, yet it remains a grey area when it comes decision around…","html":"<p>Microservice has been a game changer in software development in the last few years, yet it remains a grey area when it comes decision around maintainability and implementation of microservices. The evanglists behind microservice approach have built the case around speed, scalability and cohesion stating in that a microservice Change is easy, Units are small, scalability is semi infinite. So what is Microservice architecture? Microservices — also known as the microservice architecture — is an architectural style that structures an application as a collection of loosely coupled services, which implement business capabilities.</p>\n<p>We will discuss and summarize some of the implementation factors that have big impact on indicators of success in your project/software delivery viz:</p>\n<p><strong>Law of repository management</strong></p>\n<p>One of the most active moving part of micro services is code repositories. They can be categorised into two broader areas.</p>\n<ul>\n<li>Mono Repository i.e. keep all the services in the same repository</li>\n<li>Multiple Repositories i.e. keep separate repositories for each of the services</li>\n</ul>\n<p>Majority of microservices evolve over a period of time and it has been observed that based on team and organisation stucutures derives the strategy adobted for code management. Usually it naturally tends towards multiple repository pattern due of diverse practices followed in an organization among various units. This results in poor code reusabiliy but also provides clear boundaries of ownership. The problem of reusability can be resolve by implementing re-usable package, e.g. nugets for .net or npm for node etc. As the number of services grows it becomes difficult to debug and cross teams development. Moreover overall platform knowledge becomes fragmented and abstract due to focused development teams.</p>\n<p>For a larger project it is recomended to use Mono repository with clear segrigation of domin functionality and shared core reusability. This brings standardisation is development style and practices. It provides better integration capabilities and debugging at the cost of larger code base. Most programming framework provides modular development approach where we can leverage best of both world of mono repo for development and multi repo for build and release.</p>\n<p><strong>Law of seperation of concern</strong></p>\n<p>The most common dilemma that microservice bring into an architects plate is regarding granuality of functionality. As per recomended practice the domain driven development leads to correct size of bounded context which is articulated based on various business activities and influence. Usually, in real world it has been noticed that business units and generated based on software boundaries. Nevertheless using microservices does not implies less code, rather it focus on maintainablity and scalability. If you are planning to create a microservice for each functionality then it is definately planning for diaster. Majority of seggrigation shall be based on domain but under special scenarios it is absoluty deviate and create a seperate service based on technical feature, e.g. email service, notification service etc.</p>\n<p>The mutual independence across multiple microservices is te core principle behind this architecture. Each service shall ideally implement its own data persistence and caching capabilities. The owner service defines the strategy to create, manipulate and consume service. The external services should not be entertaining data access directly but shall only pass through owner service interfaces only.</p>\n<p>The cross cutting concers such as authentication shall be abstracted to gateways such as azure api management, <a href=\"http://threemammals.com/ocelot\">ocelot</a>. In certain senarios a aggregator microservice might be required from client or as a server rapper to avoid multiple dependenct hell. This aggregator may also act as proxy or service discovery facade.</p>\n<p><strong>Law of eventual consistency</strong></p>\n<p>Since each service is responsible for consistency and reliabiliy of its data the cross domain data passing is performed via message passing. Thus this does not result in ACID [atomic, consitent, isolated, durable] principles as these updates are not happening in transaction. This is can be solved using two phase commit but will eventually result in high coupling and the core principle of microservices are violated. The microservice arctchitecture is an advocate of CAP theorem i.e. consistent, available and partition tolerant. To achive the desired benefits of microservices the eventual consitency is implemented via</p>\n<ul>\n<li>\n<p>Event sourcing - We can query an application’s state to find out the current state of the world, and this answers many questions. However there are times when we don’t just want to see where we are, we also want to know how we got there.\nEvent Sourcing ensures that all changes to application state are stored as a sequence of events. Not just can we query these events, we can also use the event log to reconstruct past states, and as a foundation to automatically adjust the state to cope with retroactive changes. e.g. database event logs, similar implementation can be adopted for business events and each micro services can perform action independently to bring system to desired state eventually.</p>\n</li>\n<li>\n<p>CQRS - CQRS stands for Command Query Responsibility Segregation. It’s a pattern that I first heard described by Greg Young. At its heart is the notion that you can use a different model to update information than the model you use to read information. The micro service can process data and keep upto date information for serving realtime need but can update the core system from log. e.g. a notification for ecommerce order placement can be serverd seperately to updates in erp system.</p>\n</li>\n<li>\n<p>Message/Service Bus - For event based message passing in microservice either a direct call to the service can be initited or a message broker such as service bus can be implemented for asyncronous communication maintaining the high demand services to scale to serve client needs and keeping background jobs instance low.</p>\n</li>\n</ul>\n<p><strong>Law of scalable deployment</strong></p>\n<p>Easy deployment and scalability is the key feature that bought microservices into architects tool box. There are various containerisation frameworks/application that can compile into deployable image that is ready to scale. Application containerization is an OS-level virtualization method used to deploy and run distributed applications without launching an entire virtual machine (VM) for each app. Multiple isolated applications or services run on a single host and access the same OS kernel. Application containers include the runtime components — such as files, environment variables and libraries — necessary to run the desired software. Application containers consume fewer resources than a comparable deployment on virtual machines because containers share resources without a full operating system to underpin each app.</p>\n<p>The most common app containerization technology is Docker, specifically the open source Docker Engine and containerd based on universal runtime runC. The main competitive offering is CoreOS’ rkt container engine that relies on the App Container (appc) spec as its open, standard container format, but it also can execute Docker container images.</p>\n<p>Though containerisation is not required to develop and run microservices but these two concepts have be tied together as complementary services to generate maximum benefit. Most services require orchestrator such as Azure Kubernetes services, AWS fargate where that can create a instance for public or private registry such as docker hub, Azure container service etc. Now Azure app service has capability to run docker image but usually with orchestrators in place a </p>\n<p><strong>Law of green initiation</strong></p>\n<p><strong>Law of brown transition</strong></p>\n<p><strong>Law of implementation patterns</strong></p>\n<p><strong>Law of communication</strong></p>\n<p><strong>Law of Monitoring</strong></p>","fields":{"slug":"/2019-01-28-microservices-design-pattern/"},"frontmatter":{"title":"9 laws of architecting microservices","date":"January 28, 2019","tags":["micoroservices","design-patterns","technology","article"],"subTitle":"architects blackbook for microservices implementation","categories":"design-patterns"}}},"pageContext":{"slug":"/2019-01-28-microservices-design-pattern/","previous":{"fields":{"slug":"/2019-01-04-elixir-concurrency-models/"},"frontmatter":{"title":"phoenix/elixir - concurrency actor model with 'let it crash' philosophy","tags":["elixir","phoenix","actor-model","design-patterns","functional-programming","technology","article"],"categories":"technology"}},"next":null}}
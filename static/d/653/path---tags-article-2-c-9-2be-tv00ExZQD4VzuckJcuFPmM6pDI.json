{"data":{"site":{"siteMetadata":{"title":"paul blog","description":"thoughts, stories & ideas.","author":"Bipin Paul Bedi","siteUrl":"https://www.bipinpaulbedi.com"}},"allMarkdownRemark":{"totalCount":4,"edges":[{"node":{"id":"83fca52e-f506-543b-bb37-b7d9695f772c","excerpt":"A concurrent program has multiple logical threads of control. These threads may or may not run in parallel. A parallel program potentially…","fields":{"slug":"/2019-01-04-elixir-concurrency-models/"},"html":"<p>A concurrent program has multiple logical threads of control. These threads may or may not run in parallel. A parallel program potentially runs more quickly than a sequential program by executing different parts of the computation simultaneously (in parallel). It may or may not have more than one logical thread of control. An alternative way of thinking about this is that concurrency is an aspect of the problem domain—your program needs to handle multiple simultaneous (or near-simultaneous) events. Parallelism, by contrast, is an aspect of the solution domain—you want to make your program faster by processing different portions of the problem in parallel.</p>\n<p>Functional programming avoids the problems associated with shared mutable state by avoiding mutable state. Actor programming, by contrast, retains mutable state but avoids sharing it. An actor is like an object in an object-oriented (OO) program—it encapsulates state and communicates with other actors by exchanging messages. The difference is that actors run concurrently with each other and, unlike OO-style message passing (which is really just calling a method), actors really communicate by sending messages to each other.</p>\n<p>Certainly, there are some concurrent programs that will always be nondeterministic. And this is unavoidable—some problems require solutions that are intrinsically dependent on the details of timing. But it’s not the case that all parallel programs are necessarily nondeterministic. The value of the sum of the numbers between 0 and 10,000 won’t change just because we add those numbers together in parallel instead of sequentially</p>\n<p>Microsoft <a href=\"https://dotnet.github.io/orleans/\">Orleans</a> is .net implementation of Actor Model but we will focus on programming language which was build with focus on concurrent execution. Elixir/Erlang: Erlang is a programming language used to build massively scalable soft real-time systems with requirements on high availability. Some of its uses are in telecoms, banking, e-commerce, computer telephony and instant messaging. Erlang’s runtime system has built-in support for concurrency, distribution and fault tolerance.\nOTP is set of Erlang libraries and design principles providing middle-ware to develop these systems. It includes its own distributed database, applications to interface towards other languages, debugging and release handling tools. Erlang runs on VM called BEAM which is esentially a <a href=\"https://en.wikipedia.org/wiki/Virtual_machine\">process virtual machine</a></p>\n<p><code class=\"language-text\">In Erlang, and therefore Elixir, an actor is called a process. In most environments a process is a heavyweight entity that consumes lots of resources and is expensive to create. An Elixir process, by contrast, is very lightweight—lighter weight even than most systems’ threads, both in terms of resource consumption and startup cost. Elixir programs typically create thousands of processes without problems and don’t normally need to resort to the equivalent of thread pools</code></p>\n<p><strong>Elixir actor by example</strong>  </p>\n<p>Elixir actors communicate via message passing using mailboxes, which are queues by data structure. For our example we will create a hash generater which based on a string return a complex crypto. If the value is already exiting it will not recompute to save cpu resource but send from in memory cache.</p>\n<p><code class=\"language-text\">defmodule HashIt do  \n    def loop do  \n        receive do  \n            {:compute, value} -&gt; IO.puts(&quot;#{value}&quot;)  \n        end  \n        loop  \n    end  \nend</code></p>","frontmatter":{"date":"January 04, 2019","title":"phoenix/elixir - concurrency actor model with 'let it crash' philosophy"}}},{"node":{"id":"6c7a3c9e-c426-5c72-adf4-29466a385e72","excerpt":"The asymptotic notation is the mathematical representation to analyze algorithm and represent its time (and/or space) complexity as its…","fields":{"slug":"/2018-10-20-asymtotic-notations/"},"html":"<p>The asymptotic notation is the mathematical representation to analyze algorithm and represent its time (and/or space) complexity as its relation to input size. It describes its behavioral characteristics as the input size for the algorithm increases. The algorithm complexity can also be measured by monitoring time and space usage during its actual physical execution. This approach is not ideal for the following reasons  </p>\n<p>The accuracy and relativity (times obtained would only be relative to the machine they were computed on) of this method is bound to environmental variables such as computer hardware specifications, processing power, etc.<br>\nTo conclude a general behavior we would have to execute it in several different scenarios.  </p>\n<p>Thus by representing an algorithm using asymptotic notation, it is much easier, faster and standard methodology to analyze and compare algorithms. For this post, we will restrict our discussion to time complexities {since the tremendous technological advancement has led to the cost of storage (persistent or ephemeral) as negligible}. In any problem domain, for a given algorithm f, with input size n we calculate some resultant runtime f(n). This results in a graph where the Y-axis is the runtime, X-axis is the input size, and plot points are the resultants of the amount of time for a given input size. We would mostly measure the worst-case scenario for any algorithm to compare different algorithms against the standard set of facts and dimentions.  </p>\n<p>Before analysing the algorithms, we shall establish certain common complexity classes in which an algorithm can be classified i.e. g(n) viz. K (or constant), log n, n, n*log n, n^2, n^3…, 2^n, 3^n…n^n  </p>\n<p><strong>Types of Asymptotic Notation</strong>  </p>\n<p><strong>Big-O</strong><br>\nBig-O, commonly written as O, is an Asymptotic Notation for the worst case, or ceiling of growth for a given function. It provides us with an asymptotic upper bound for the growth rate of the runtime of an algorithm.<br>\nFor e.g. f(n) is your algorithm runtime, and g(n) is an arbitrary time complexity you are trying to relate to your algorithm. f(n) is O(g(n)), if for some real constants c (c > 0) and n0, f(n) &#x3C;= c g(n) for every input size n (n > n0)  </p>\n<p><code class=\"language-text\">f(n) = O(g(n) For K and N0</code><br>\n<code class=\"language-text\">if f(n) &lt;= k * g(n) where n&gt;=n0</code><br>\n<code class=\"language-text\">e.g.</code><br>\n<code class=\"language-text\">f(n) = 2n^2 + 3n + 1</code>\n<code class=\"language-text\">since 2n^2 + 3n^2 + n2 = 6n^2</code><br>\n<code class=\"language-text\">f(n) = 2n^2 + 3n + 1 &lt;= 6n^2 for n &gt;= ?</code><br>\n<code class=\"language-text\">f(n) &lt;= k * g(n)</code><br>\n<code class=\"language-text\">i.e. 6 * n^2</code><br>\n<code class=\"language-text\">Thus f(n) = O(n^2)</code></p>\n<p><strong>Big-Omega</strong><br>\nBig-Omega, commonly written as Ω, is an Asymptotic Notation for the best case, or a floor growth rate for a given function. It provides us with an asymptotic lower bound for the growth rate of the runtime of an algorithm.<br>\nf(n) is Ω(g(n)), if for some real constants c (c > 0) and n0 (n0 > 0), f(n) is >= c g(n) for every input size n (n > n0).  </p>\n<p><code class=\"language-text\">f(n) = BIG-OMEGA(g(n) For K and N0</code><br>\n<code class=\"language-text\">if f(n) &gt;= k * g(n) where n&gt;=n0</code><br>\n<code class=\"language-text\">e.g.</code><br>\n<code class=\"language-text\">f(n) = 2n^2 + 3n + 1</code>\n<code class=\"language-text\">f(n) = 2n^2 + 3n + 1 &gt;= n^2 for n &gt;= ?</code><br>\n<code class=\"language-text\">f(n) &lt;= k * g(n)</code><br>\n<code class=\"language-text\">i.e. 1 * n^2</code><br>\n<code class=\"language-text\">or k * g(n)</code><br>\n<code class=\"language-text\">Thus f(n) = BIG-OMEGA(n^2)</code></p>\n<p><strong>Theta</strong><br>\nTheta, commonly written as Θ, is an Asymptotic Notation to denote the asymptotically tight bound on the growth rate of the runtime of an algorithm.<br>\ni.e. if O(g(n)) = Ω(g(n))<br>\nThen<br>\nf(n) = Θ(g(n))</p>\n<p><code class=\"language-text\">If f(n) = O(n2)</code><br>\n<code class=\"language-text\">and f(n) = BIG-OMEGA(n^2)</code><br>\n<code class=\"language-text\">also</code><br>\n<code class=\"language-text\">f(n) = O(g(n)) and f(n) = BIG-OMEGA(g(n))</code>\n<code class=\"language-text\">Then f(n) = THETA(g(n))</code><br>\n<code class=\"language-text\">Thus f(n) = THETA(n^2)</code></p>\n<p>Note\nThe asymptotic growth rates provided by big-O and big-omega notation may or may not be asymptotically tight. Thus we use small-o and small-omega notation to denote bounds that are not asymptotically tight.</p>\n<p>The main difference is that in f(n) = O(g(n)), the bound f(n) &#x3C;= g(n) holds for <strong>some</strong> constant c > 0, but in f(n) = o(g(n)), the bound f(n) &#x3C; c g(n) holds for <strong>all</strong> constants c > 0.\nSimilarly\nf(n) = Ω(g(n)), the bound f(n) >= g(n) holds for <strong>some</strong> constant c > 0, but in f(n) = ω(g(n)), the bound f(n) > c g(n) holds for <strong>all</strong> constants c > 0.</p>\n<p><code class=\"language-text\">Calculating for n!</code><br>\n<code class=\"language-text\">if f(n) = n!</code><br>\n<code class=\"language-text\">f(n) = n * (n-1) * (n-2)... 2 * 1</code>\n<code class=\"language-text\">For upper bound = n * n * n * n * n * n * n</code><br>\n<code class=\"language-text\">i.e. f(n) = n! &lt;= n^n for n&gt;=?</code><br>\n<code class=\"language-text\">f(n) = O(n^n)</code>\n<code class=\"language-text\">For lower bound = 1 * 1 * 1 * 1 * 1...1</code>\n<code class=\"language-text\">= k</code>\n<code class=\"language-text\">Thus f(n) =  BIG-OMEGA(1) or BIG-OMEGA(K)</code><br>\n<code class=\"language-text\">since O and BIG-OMEGA for n! is not equal it does not have a tight bound</code> </p>","frontmatter":{"date":"October 20, 2018","title":"ELI5 - Asymptotic computational complexity simplified"}}},{"node":{"id":"d6824ac9-1d20-5831-9ad4-fdb5848efabb","excerpt":"The most difficult and time consuming activity in any machine learning project is modelling the domain. The objective of training the model…","fields":{"slug":"/2018-10-12-regularization-for-machine-learning-models/"},"html":"<p>The most difficult and time consuming activity in any machine learning project is modelling the domain. The objective of training the model is to reduce the cost function, which can have direct dependency on feature selection and their representation. The results you achieve is a function of the model features and the weights being selected. Even your framing of the problem and measures you’re using to estimate accuracy play a part. Your results are dependent on many inter-dependent properties</p>\n<blockquote>\n<p>Feature engineering is the process of transforming raw data into features that better represent the underlying problem to the predictive models, resulting in improved model accuracy on unseen data.</p>\n</blockquote>\n<p>You can see the dependencies in this definition:</p>\n<ul>\n<li>The performance measures you’ve chosen (RMSE? AUC?)</li>\n<li>The framing of the problem (classification? regression?)</li>\n<li>The predictive models you’re using (SVM?)</li>\n<li>The raw data you have selected and prepared (samples? formatting? cleaning?)</li>\n</ul>\n<p>In order to create less complex model when you have a large number of features in your dataset, some of the Regularization techniques are used to address over-fitting. In general, due to the addition of regularization term, the values of weight matrices decrease because it assumes that a neural network with smaller weight matrices leads to simpler models.</p>\n<p><code class=\"language-text\">Cost function = Loss + Regularization term</code></p>\n<p>L1 and L2 are the most common types of regularization. The key difference between these two is the penalty term</p>\n<p><strong>L1 regularization</strong><br>\nA regression model that uses L1 regularization technique is called Lasso Regression</p>\n<p><code class=\"language-text\">Cost function = Loss + &amp;Lambda;/2m * &amp;Sigma;&amp;#124;weight&amp;#124;</code></p>\n<p>Here, lambda is the regularization parameter. It is the hyperparameter whose value is optimized for better results. if lambda is zero then you can imagine we get back original loss. However, if lambda is very large then it will add too much weight and it will lead to under-fitting.<br>\nIn L1 regularization, we penalize the absolute value of the weights. The weights may be reduced to zero here. Hence, it is very useful when we are trying to compress our model. Otherwise, we usually prefer L2 over it.</p>\n<p><strong>L2 regularization</strong><br>\nA regression model model which uses L2 is called Ridge Regression.</p>\n<p><code class=\"language-text\">Cost function = Loss + &amp;Lambda;/2m * &amp;Sigma;&amp;#124;weight&amp;#124;^2</code></p>\n<p>It adds “squared magnitude” of coefficient as penalty term to the loss function. L2 regularization is also known as weight decay as it forces the weights to decay towards zero (but not exactly zero).</p>\n<p>The key difference between these techniques is that in L1 the less important feature’s coefficient are reduced to zero thus, removing some feature altogether. So, this works well for feature selection in case we have a huge number of features.</p>","frontmatter":{"date":"October 12, 2018","title":"L1 & L2 model regularizations techniques"}}},{"node":{"id":"e0ec1d27-f812-5cad-afe8-e1dc91abf91e","excerpt":"As per Wikipedia, Design thinking is the cognitive process from which design concepts (e.g. ideas for products) emerge. Design thinking is…","fields":{"slug":"/2018-10-10-coding-blueprint-for-pragmatic-rest-api-developers/"},"html":"<p>As per Wikipedia, Design thinking is the cognitive process from which design concepts (e.g. ideas for products) emerge. Design thinking is related to, but is different from problem-solving, decision-making, creativity, sketching and prototyping. During design thinking, the designer’s attention oscillates between their understanding of a problem context and their ideas for a solution. New solution ideas lead to a deeper understanding of the problematic context, which in turn triggers more solution ideas.</p>\n<p>When your focus acts like a pendulum between problem context and the creative solution then you are bound to wear multiple hats. The irony as the developer when designing API is that your clients are other developers.\nOver the past decade after working under some fine mentors the summary of the learning can be stated as “Think of developing API endpoints for a command line interface, possibly it will result in self-understandable, complete solution you are seeking”.</p>\n<p>This post is inspired by eBook published by APIgee highlighting the best practiced for REST design. As an API designer, I have gone through some challenges myself, viz.</p>\n<p><strong>What should be my base URL?</strong></p>\n<p>Keep it short and simple. Try to use nouns and keep verbs out of your base URL. To smartly cover all possible scenario use HTTP verb standard.\nEg.</p>\n<table>\n<thead>\n<tr>\n<th>Resource</th>\n<th align=\"center\">POST</th>\n<th align=\"center\">GET</th>\n<th align=\"center\">PUT</th>\n<th align=\"center\">DELETE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td align=\"center\">create</td>\n<td align=\"center\">read</td>\n<td align=\"center\">update</td>\n<td align=\"center\">delete</td>\n</tr>\n<tr>\n<td>/users</td>\n<td align=\"center\">create a new user</td>\n<td align=\"center\">list users</td>\n<td align=\"center\">bulk update users</td>\n<td align=\"center\">delete all users</td>\n</tr>\n<tr>\n<td>/users/1234</td>\n<td align=\"center\">error</td>\n<td align=\"center\">show user</td>\n<td align=\"center\">update if exists or error</td>\n<td align=\"center\">delete user</td>\n</tr>\n</tbody>\n</table>\n<p>The point is that developers probably don’t need the chart to understand how the API behaves. They can experiment with and learn the API without the documentation.</p>\n<p><strong>Shall I use plurals or singular nouns?</strong></p>\n<p>The recommended practice is to use plurals since the first API being tested by developers is most probably GET and GET /users to list all users make natural sense. Irrespective whatever you choose, be consistent to avoid confusing your API consumers. Moreover, concrete names are better than abstract ones. Eg. Having an endpoint like /blogs or /videos over abstract names like /items or /contents can help the consumer to identify resources more conveniently.<br>\nYou also want to expose a manageable number of resources. Aim for concrete naming and keep the number of resources between 12 and 24.</p>\n<p><strong>How should the relations and associations be exposed in API?</strong></p>\n<p>Resource always have relationships with other resources. oData standard makes it easier for developers to navigate resource and its association using metadata, it can be also let to exposing your information schema.<br>\nThe recommended practise is to follow ‘resource/identity/resource’ model eg. /users/1234/department. It’s not uncommon to see people string these together making a URL 5 or 6 levels deep. Remember that once you have the primary key for one level, you usually don’t need to include the levels above because you’ve already got your specific object.</p>\n<p><strong>How do we handle the complexity of pagination, partial response, filters etc.?</strong></p>\n<p>Make it simple for developers to use the base URL by putting optional states and attributes behind the query string question mark. E.g. GET /users?name=xxx<br>\nFor pagination request for limit and offset eg. GET /users?limit=50&#x26;offset=100 additionally, request fields to make it precise. Avoid using special characters in the query string. A good API always have defaults for pagination.<br>\nGood example /GET users?fields=name,gender<br>\nBad example /Get users:(name,gender)<br>\nWe also suggest including metadata with each response that is paginated that indicated to the developer the total number of records available. Use JSON-LD/HAL/Collection+JSON/SIREN/JSONAPI.ORG specifications as your starting point and don’t forget to be creative.</p>\n<p><strong>What is the recommended practice for error handling?</strong></p>\n<p>The developers learn to write code through error and trial, most important they rely on error messages during critical times for troubleshooting and resolving issues.<br>\nAs the best practice always serve the error messages with correct HTTP status codes, also include a verbose error message with as many details as possible. We highly recommend that you add a link in your description to add more information.<br>\nIn certain circumstances the framework used by developer intercepts the message and follows the default routine, thus developer may have no opportunity to inform his user appropriately. Thus, if you can provide a flag to suppress the status code and result in HTTP - 200 OK with actual status code and the message passed along with the payload.</p>\n<p><strong>Shall we version control the API?</strong></p>\n<p>Never release an API without a version and make the version mandatory. Keep the version naming simple and maintain compatibility with at least one version backwards for minimum 6-12 months.<br>\nSome developers advocate as to keep the version information in headers. But API can have breaking changes, thus being verbose and explicitly specifying version numbers in URL can help developers identify gaps early.</p>\n<p><strong>What about responses that don’t involve resources?</strong></p>\n<p>In certain cases, API calls that sends a response which is not a resource e.g. Calculate, Translate are not uncommon depending on the domain.\nIn these cases, Use verbs not nouns e.g. /convert?from=USD&#x26;to=AUD&#x26;amount=100<br>\nMake it clear in your API documentation that these “non-resource” scenarios are different, maybe in you swagger docs.<br>\n<br>\n<strong>How many formats shall we support?</strong></p>\n<p>Respect the HTTP header content-type and accepts e.g. Accept: application/json but let the user override using dot notation e.g. GET /user/1234.dat or GET /user/1234.xml<br>\nIf the default form is JSON, in the response properties try using camelCase for attributes as it is easier for the front-end developer to parse into objects with standard JavaScript conventions.</p>\n<p><strong>Any other tips and tricks?</strong></p>\n<p><em>Tip1:</em><br>\nA simple can be verb based resourceful API but for complex scenarios use google model\ne.g.<br>\n/search?q=xxx<br>\n/user?q=xxx<br>\n/location/1234/user=xxx – scoped<br>\n/search.xml?q=xxx – formatted  </p>\n<p><em>Tip2:</em><br>\nConsolidate API under a single domain with segregation for environments following a standard pattern e.g.\napi.xxx.com\nuat-api.xxx.com\ndev-api.xxx.com</p>\n<p><em>Tip3:</em><br>\nUse standard known authentication/authorization methodologies e.g. oAuth2.0 etc</p>\n<p><em>Tip4:</em><br>\nTry to complement your API with SDK</p>\n<p><em>Tip5:</em><br>\nUsing POST to emulate PUT, DELETE, PATCH. If your development platform or firewall rules prevent you from calling HTTP methods like PUT, PATCH or DELETE, use the X-HTTP-Method-Override header. Pass the method you want to use in the X-HTTP-Method-Override header and make your call using the POST method</p>\n<p><strong>What API design pattern is an ideal choice in most cases?</strong></p>\n<p>The architect must carefully evaluate available options and what suits the business domain and skill set of available developers in terms of project support and maintainability. But in most cases, an API Façade with mediate to complement can cover the majority of cases. This is covered in detail in another post.</p>","frontmatter":{"date":"October 10, 2018","title":"Developers guide to designing REST endpoints"}}}]}},"pageContext":{"tag":"article"}}
{"data":{"site":{"siteMetadata":{"title":"paul blog","description":"thoughts, stories & ideas.","author":"Bipin Paul Bedi","siteUrl":"https://www.bipinpaulbedi.com"}},"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"id":"83fca52e-f506-543b-bb37-b7d9695f772c","excerpt":"A concurrent program has multiple logical threads of control. These threads may or may not run in parallel. A parallel program potentially…","fields":{"slug":"/2019-01-04-elixir-concurrency-models/"},"html":"<p>A concurrent program has multiple logical threads of control. These threads may or may not run in parallel. A parallel program potentially runs more quickly than a sequential program by executing different parts of the computation simultaneously (in parallel). It may or may not have more than one logical thread of control. An alternative way of thinking about this is that concurrency is an aspect of the problem domain—your program needs to handle multiple simultaneous (or near-simultaneous) events. Parallelism, by contrast, is an aspect of the solution domain—you want to make your program faster by processing different portions of the problem in parallel.</p>\n<p>Functional programming avoids the problems associated with shared mutable state by avoiding mutable state. Actor programming, by contrast, retains mutable state but avoids sharing it. An actor is like an object in an object-oriented (OO) program—it encapsulates state and communicates with other actors by exchanging messages. The difference is that actors run concurrently with each other and, unlike OO-style message passing (which is really just calling a method), actors really communicate by sending messages to each other.</p>\n<p>Certainly, there are some concurrent programs that will always be nondeterministic. And this is unavoidable—some problems require solutions that are intrinsically dependent on the details of timing. But it’s not the case that all parallel programs are necessarily nondeterministic. The value of the sum of the numbers between 0 and 10,000 won’t change just because we add those numbers together in parallel instead of sequentially</p>\n<p>Microsoft <a href=\"https://dotnet.github.io/orleans/\">Orleans</a> is .net implementation of Actor Model but we will focus on programming language which was build with focus on concurrent execution. Elixir/Erlang: Erlang is a programming language used to build massively scalable soft real-time systems with requirements on high availability. Some of its uses are in telecoms, banking, e-commerce, computer telephony and instant messaging. Erlang’s runtime system has built-in support for concurrency, distribution and fault tolerance.\nOTP is set of Erlang libraries and design principles providing middle-ware to develop these systems. It includes its own distributed database, applications to interface towards other languages, debugging and release handling tools. Erlang runs on VM called BEAM which is esentially a <a href=\"https://en.wikipedia.org/wiki/Virtual_machine\">process virtual machine</a></p>\n<p><code class=\"language-text\">In Erlang, and therefore Elixir, an actor is called a process. In most environments a process is a heavyweight entity that consumes lots of resources and is expensive to create. An Elixir process, by contrast, is very lightweight—lighter weight even than most systems’ threads, both in terms of resource consumption and startup cost. Elixir programs typically create thousands of processes without problems and don’t normally need to resort to the equivalent of thread pools</code></p>\n<p><strong>Elixir actor by example</strong>  </p>\n<p>Elixir actors communicate via message passing using mailboxes, which are queues by data structure. For our example we will create a hash generater which based on a string return a complex crypto. If the value is already exiting it will not recompute to save cpu resource but send from in memory cache.</p>\n<p><code class=\"language-text\">defmodule HashIt do</code><br>\n   <code class=\"language-text\">def loop do</code><br>\n       <code class=\"language-text\">receive do</code><br>\n           <code class=\"language-text\">{:compute, value} -&gt; IO.puts(&quot;#{value}&quot;)</code> will replace #{value} with computed hash function<br>\n       <code class=\"language-text\">end</code><br>\n       <code class=\"language-text\">loop</code><br>\n   <code class=\"language-text\">end</code><br>\n<code class=\"language-text\">end</code><br>\n<code class=\"language-text\">----------</code><br>\n<code class=\"language-text\">pid = spawn(&amp;HashIt.loop/0)</code><br>\n<code class=\"language-text\">send(pid, {:compute, &quot;bipin&quot;})</code><br>\n<code class=\"language-text\">sleep(1000)</code>  </p>\n<p>This function implements an infinite loop by calling itself recursively. The receive block waits for a message and then uses pattern matching to work out how to handle it.  Elixir implements tail-call elimination. Tail-call elimination, as its name suggests, replaces a recursive call with a simple jump if the last thing the function does is call itself, thus infinite recursive call o loop function will not result in stack overflow.</p>\n<p><code class=\"language-text\">defmodule HashIt do</code><br>\n   <code class=\"language-text\">def loop do</code><br>\n       <code class=\"language-text\">receive do</code><br>\n           <code class=\"language-text\">{:compute, value} -&gt; IO.puts(&quot;#{value}&quot;)</code> replace #{value} with computed hash function<br>\n           <code class=\"language-text\">{:shutdown} -&gt;  -&gt; exit(:normal)</code><br>\n       <code class=\"language-text\">end</code><br>\n       <code class=\"language-text\">loop</code><br>\n   <code class=\"language-text\">end</code><br>\n<code class=\"language-text\">end</code><br>\n<code class=\"language-text\">----------</code><br>\n<code class=\"language-text\">receive do</code><br>\n   <code class=\"language-text\">{:EXIT, ^pid, reason} -&gt; IO.puts(&quot;HasIt has exited (#{reason})&quot;)</code><br>\n<code class=\"language-text\">end</code></p>\n<p><code class=\"language-text\">Process.flag(:trap_exit, true)</code><br>\n<code class=\"language-text\">pid = spawn_link(&amp;HashIt.loop/0)</code><br>\n<code class=\"language-text\">send(pid, {:compute, &quot;bipin&quot;})</code><br>\n<code class=\"language-text\">send(pid, {:shutdown}</code>  </p>\n<p><strong>Adding state to the actor</strong>  </p>\n<p>We will add a variable to store all values sent and their computed hash</p>\n<p><code class=\"language-text\">defmodule HashIt do</code><br>\n   <code class=\"language-text\">def loop(strg) do</code><br>\n       <code class=\"language-text\">receive do</code><br>\n           <code class=\"language-text\">{:compute, value} -&gt;</code><br>\n             <code class=\"language-text\">updatedStrg = strg.put(strg, value, compute())</code>  replace compute() with computed hash function<br>\n             <code class=\"language-text\">IO.puts(&quot;#{value}&quot;)</code>\n              <code class=\"language-text\">loop(updatedStrg)</code><br>\n       <code class=\"language-text\">end</code><br>\n       <code class=\"language-text\">loop</code><br>\n   <code class=\"language-text\">end</code><br>\n<code class=\"language-text\">end</code>  </p>\n<p>Here Strg is an elixir <a href=\"https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/hash_dict.ex\">hash dictionary</a> which </p>","frontmatter":{"date":"January 04, 2019","title":"phoenix/elixir - concurrency actor model with 'let it crash' philosophy"}}}]}},"pageContext":{"tag":"elixir"}}
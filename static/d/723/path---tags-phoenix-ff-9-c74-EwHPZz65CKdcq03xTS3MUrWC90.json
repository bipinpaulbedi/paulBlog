{"data":{"site":{"siteMetadata":{"title":"paul blog","description":"thoughts, stories & ideas.","author":"Bipin Paul Bedi","siteUrl":"https://www.bipinpaulbedi.com"}},"allMarkdownRemark":{"totalCount":1,"edges":[{"node":{"id":"83fca52e-f506-543b-bb37-b7d9695f772c","excerpt":"A concurrent program has multiple logical threads of control. These threads may or may not run in parallel. A parallel program potentially…","fields":{"slug":"/2019-01-04-elixir-concurrency-models/"},"html":"<p>A concurrent program has multiple logical threads of control. These threads may or may not run in parallel. A parallel program potentially runs more quickly than a sequential program by executing different parts of the computation simultaneously (in parallel). It may or may not have more than one logical thread of control.</p>\n<p>An alternative way of thinking about this is that concurrency is an aspect of the problem domain—your program needs to handle multiple simultaneous (or near-simultaneous) events. Parallelism, by contrast, is an aspect of the solution domain—you want to make your program faster by processing different portions of the problem in parallel.</p>\n<p>Functional programming avoids the problems associated with shared mutable state by avoiding mutable state. Actor programming, by contrast, retains mutable state but avoids sharing it. An actor is like an object in an object-oriented (OO) program—it encapsulates state and communicates with other actors by exchanging messages. The difference is that actors run concurrently with each other and, unlike OO-style message passing (which is really just calling a method), actors really communicate by sending messages to each other. </p>\n<p>Microsoft <a href=\"https://dotnet.github.io/orleans/\">Orleans</a> is .net implementation of Actor Model</p>\n<p><strong>Types of Asymptotic Notation</strong>  </p>\n<p><strong>Big-O</strong><br>\nBig-O, commonly written as O, is an Asymptotic Notation for the worst case, or ceiling of growth for a given function. It provides us with an asymptotic upper bound for the growth rate of the runtime of an algorithm.<br>\nFor e.g. f(n) is your algorithm runtime, and g(n) is an arbitrary time complexity you are trying to relate to your algorithm. f(n) is O(g(n)), if for some real constants c (c > 0) and n0, f(n) &#x3C;= c g(n) for every input size n (n > n0)  </p>\n<p><code class=\"language-text\">f(n) = O(g(n) For K and N0</code><br>\n<code class=\"language-text\">if f(n) &lt;= k * g(n) where n&gt;=n0</code><br>\n<code class=\"language-text\">e.g.</code><br>\n<code class=\"language-text\">f(n) = 2n^2 + 3n + 1</code>\n<code class=\"language-text\">since 2n^2 + 3n^2 + n2 = 6n^2</code><br>\n<code class=\"language-text\">f(n) = 2n^2 + 3n + 1 &lt;= 6n^2 for n &gt;= ?</code><br>\n<code class=\"language-text\">f(n) &lt;= k * g(n)</code><br>\n<code class=\"language-text\">i.e. 6 * n^2</code><br>\n<code class=\"language-text\">Thus f(n) = O(n^2)</code></p>","frontmatter":{"date":"January 04, 2019","title":"phoenix/elixir - concurrency actor model with 'let it crash' philosophy"}}}]}},"pageContext":{"tag":"phoenix"}}